## 编译系统

```c
#include <stdio.h>
int main()
{
    printf("%s","hello world");
    return 0;
}
```

1. 预处理(cpp)根据字符`#` 开头的命令，修改原始的c程序。比如上面代码中第一行开头的`#include <stdio.h>` 命令告诉预处理器读取系统头文件`stdio.h` 的内容，并把它直接插入到程序文本中。（`hello.i`）
2. 编译阶段。编译器(cel)将文本`hello.i` 翻译成文本文件`hello.s`，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种表中的文本格式确切地描述了一条低级机器语言指令。
3. 汇编阶段。汇编器(as)将`hello.s` 翻译成机器语言指令，并将结果保存在目标文件`hello.o` 。该文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。
4. 链接阶段。hello 程序调用了`printf` 函数，它是每个c编译器都会提供的标准c库中的一个函数。`printf` 函数存在于一个名为`printf.o` 的单独预编译好了的目标文件中，而这个文件必须以某中方式合并到`hello.o` 文件中。链接器就负责处理这种合并。结果就是得到`hello`文件。它是一个可执行目标文件（或者简称为可执行文件），可以被加载都是内存中，有系统执行。

## 类型、运算符与表达式

### 数据类型

```c
char
int
float
double
```

### 常量

```c
//定义
  #define INCHES_PER_FOOT 12

/*
  常量表达式: 是仅仅只包含常量的表达式。这种表达式在编译时求值，而不在运行时求值。它可以出现在常量可以出现的任何位置。
*/
  #define MAXLINE 1000
  chat line[MAXLINE+1];

/*
  1. 字符串常量：就是字符数组。字符串的内部表示使用一个空字符'\0' 作为串的结尾，因此。存储字符串的物理存储单元数比在双括号的字符数多一个。这种表示方法也说明，c 语言对字符串的长度没有限制。但程序必须扫描完整的字符串后才能确定字符串的长度。
  2. 'x' 和 "x" 区别：前者是一个整数，后者是一个包含一个字符（x）以及一个结束符 '\0' 的字符数组。
*/
  "hello, world"
```

### 声明

```c
int lower, upper, step;  //批量声明
int c;  //单个声明
int i = 0; //声明并且初始化

/*
  1. 任何变量的声明都可以使用 const 限定符限定。
  2. 该限定符指定变量的值不能被修改。
  3. 对数组而言，const 限定符指定数组所有元素的值都不能被修改。
*/
  const double e = 2.7189939303;
  const char msg[] = "warning: ";

/*
  const 限定符也可配合数组参数使用，它表明函数不能修改数组元素的值：
*/
  int strlen(const char[]);
```

### 类型转换

1. 标准库文件 `<ctype.h>` 定义了一组与字符集无关的测试和转换函数。

### 作用域规则

1. 变量的声名和定义，变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此之外换将引起存储器的分配。

2. `extern` ：在外部变量定义之前是使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中。则必须在相应的变量声明中强制性地使用关键字 extern。**extern 声明数组的时候不一定要指定数组的长度。** 

   ```c
   //module.c
     #include <stdio.h>
     int m = 100;
     void func(){
       printf("Multiple file pro\n");
     }
   //main.c
     #include <stdio.h>
     extern void func();
     extern int m;
   
     int n = 200;
     int main(){
       func();
       printf("m = %d,n = %d\n",m,n);
       return 0;
     }
   
   //gcc -o main.c module.c hello
   
   //数组的声明
     extern double val[];
   ```

### 静态变量

1. 对于静态**全局变量**来说，针对某一源文件的以static声明的文件级变量与函数的作用域只限于文件内（只在文件可见）。可以用来限定变量作用域。
2. 在函数内以static声明的变量虽然与自动局部变量的作用域相同（即作用域都只限于函数内），但存储空间是以静态分配而非默认的自动分配方式获取的，因而存储空间所在区域不同（一般来说，静态分配时存储空间于编译时在程序数据段分配，一次分配全程有效；而自动分配时存储空间则是于调用栈上分配，只在调用时分配与释放），且两次调用间变量值始终保持一致；必须注意，静态局部变量只能初始化一次，这是由编译器来保证实现。

```c
#include <stdio.h>

static int f = 0; //只限当前源文件使用，同时这个变量名也不会和在其他文件的相同名字相冲突。
void func() {
  static int x = 0; // 在对func的三次调用中,x只进行一次初始化
  printf("%d\n", x); // 输出x的值
  x = x + 1;
}

int main(int argc, char * const argv[]) {
  func(); // 输出0
  func(); // 输出1
  func(); // 输出2
  return 0;
}
```

### 寄存器变量

1. 使用场景：当对一个变量频繁读写时，需要反复访问内存，从而花费大量的存取时间。通过 register 可以将这种变量存放在 CPU 的寄存器中。使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率。

2. 声明：只能在局部变量和形参才可以定义为寄存器变量。

3. `register` 是一个建议型关键字，意指程序建议该变量放在寄存器中，但最终该变量可能因为条件不满足并未成为寄存器变量，而是被放在存储器中，但编译器不会报错。

   ```c
   #include <stdio.h>
   int add(int n);
   
   int main(int argc, char * const argv[]) {
     int d = add(10);
     printf("%d\n", d);
     return 0;
   }
   
   int add(int n){
     register int i,s =0;
     for(i=1;i<=n;i++){
       s = s+i;
     }
     return s;
   }
   ```

### 初始化

1. 在不进行显示初始化的情况下，全局变量和静态变量都将初始化为0，而局部变量和寄存器变量的初值则没有定义。

2. 对于全局变量与静态变量来说，初始化表达式必须时常量表达式，且只初始化一次。对于局部变量与寄存器变量，则在每次进入函数或程序块时都将初始化。

3. 数组的初始化。

   ```c
   //正确的初始化	
     int days[] = {31,28,31,30};
   
   /*
     1. 当省略数组的长度时，编译器将把花括号中初始化表达式的个数作为数组的长度。
     2. 如果初始化表达式的个数比数组元素少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0；如果初始化表达式的个数比数组元素多，则是错误。
     3. 不能一次将一个初始化表达式指定给多个数组元素，也不能跳过前面的数字元素直接初始化后面的数组元素。
   */
     int day[],int ff[] = {31,32,33}; //error
   
   /*
     字符串数组声明
   */
     char pattern[] = "ould";
     char pattern[] = {'o','u','l','d'}; //等价
   ```

### c 预处理器

## 指针和数组

1. 指针是一种保存变量地址的变量。
2. 类型名 void* 表示没有指定类型，所以 void* 类型的指针可以包含任意类型的数据项地址。类型 void* 常常用做参数类型，或以独立于类型的方式处理数据的函数的返回值类型，在使用它时，再将其转换为合适的类型。

### 指针与地址

1. 一元运算符 `&` 可用于取一个对象的地址

   ```c
   //把c的地址赋值给变量p，称p为指向c的指针。 
   p = &c;
   ```

2. 地址运算符 `&` 只能应用于内存中的对象，即变量与数组元素。它不能作用于表达式、常量或者 `register` 类型的变量。

3. 一元运算符 `*` 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。

   ```c
   int x = 1,y = 2, z[10];
   int *ip /* ip 是一个int的指针 */
   ip = &x; /* ip 现在指向变量 x*/
   y = *ip /* y 现在为1 */
   *ip = 0; /* x 现在是0 */
   ```

4. **声明**

   ```c
   //声明指针
     int *ip;
   //使用
     /*
      int x = 1;
      int *ip = &x;
      1. 如果指针ip指向整型变量，那么在x可以出现的任何上下文中都可以使用 *ip。
         *ip = *ip +10;
      2. 把 *ip 指向的对象的值取出来并加1，然后再将结果复制给 ip。
         *ip += 1
     */
   ```

5. 指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身）。

### 指向常量的指针

声明指针时，可以使用 const 关键字指定，该指针指向的值不能改变。

```c
int value = 9999;
const int *pvalue = &value;
//pvalue 指向的值不能改变
//*pvalue = 888L;
//可以对 value 进行任意操作
value  = 777L;
//如下是可以的。
int val = 888;
pvalue = &val;
```

### 常量指针

1. 声明指针时，使的指针中存储的地址不能改变。

   ```c
   int count = 43;
   int *const pcount = &count;
   ```

2. pcount 该指针存储的地址不能改变。编译器会检查代码是否无意中把指针指向其他地方。

   ```c
   //报错
   int item = 34;
   pcount = &item;
   ```

3. 但使用 pcount，仍可以改变 pcount 指向的值

   ```C
   *pcount = 345;
   ```

### 指针与函数参数

c 语言是以传值的方式将参数传递给被调用函数。

```c
#include <stdio.h>
void swap(int *px, int *py);

int main()
{
  int a = 10, b = 9;
  swap(&a, &b);
  printf("a=%d,b=%d\n", a, b);
}

void swap(int *px, int *py)
{
  int temp;
  temp = *px;
  *px = *py;
  *py = temp;
}
```

### 指针与数组

1. 当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址。在调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值的变量。

   ```c
   //eg
     int strlen(char *s)
     {
       int n;
       for (n = 0; *s != '\0', s++){
         n++;
       }
       return n;
     }
   ```

2. 数组名和指针之间有一个不同之处，指针是一个变量，因此，在 c 语言中，语句 `pa=a` 和 `pa++` 都是合法的。但数组名不是变量，因此，类似于 `a =pa` 和 `a++ `形式的语句是非法的。

3. 在函数定义中，下面的方式是等价的。

   ```c
   int strlen(char s[]);
   int strlen(char *s);
   ```

### 地址算术运算

1. 指针与整数之间不能相互转换，但 0 是唯一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 比较。程序中经常用符号常量 `NULL` 代替常量 0。符号常量 `NULL` 定义在标准头文件 `<stddef.h>` 中。

   ```c
   #include <stdio.h>
   
   int main()
   {
     int *a = 0;
     int b = 9;
     a = &b;
     a = 0;
   }
   ```

2. 在某些情况下对指针可以进行比较运算。例如，如果指针 p 和 q 指同一个数组的成员，那么它们之间可以进行类似于 `==`、`!=` 、`<`、`>=`。但是指向不同数组的元素的指针之间的算术或者比较运算没有意义。

3. 任何指针与 0 进行相等和不等的比较运算都有意义。

   ```c
   #include <stdio.h>
   
   int main()
   {
     int a[5] = {1,2,3,4,5};
     int *b,*c,*d;
     b = &a[1];
     c = &a[2];
     d = &a[1];
     printf("%d\n",c > d); // 1 true
     printf("%d\n",d > c); // 0 false
     printf("%d\n",d == b); //1 true
     printf("%d\n",d >= b); // 1 true
   }
   ```

4. 指针运算的意义

   * 头文件`<stddef.h>` 中定义 `ptrdiff_t` 足以表示两个指针之间（字符串的字符数）的带符号差值。（示例 2 中）

   ```c
   #include <stdio.h>
   
   int main()
   {
     int *p;
     int a[3] = {1,2,3};
     p = a; //指向 a[0] 元素的地址
     /*
       1. 表示指针 p 当前指向的对象之后第 1 个对象的地址。
       2. 而 p 指向的对象的长度则取决于 p 的声明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按照 4 的倍数来计算的。
     */
     printf("%d\n",*(p+1));
   }
   
   /*
     如果 p 和 q 指向相同数组中的元素，且 p < q，那么 q - p + 1 就是位于 p 和 q 指向的元素之间的元素的数目。
   */
   int strlen(char *s)
   {
     char *p = s;
     while (*p != '\0') {
       p++;
     }
     return p-s;
   }
   ```

### 字符指针与函数。

1. 字符串常量是一个字符串数组，在字符串的内部表示中，字符数组以空字符 `'\0'` 结尾。所以，程序可以通过检查空字符找到字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大1。

   ```c
   "I am a string"
   ```

2. 进栈和出栈的标准用法。

   ```c
   *p++ = val; /* 将 val 压入栈 */
   val = *--p; /* 将栈顶元素弹出到 val 中 */
   ```

### 指针数组以及指向指针的指针。

```c
//表示 lineptr 是一个具有 10 个元素的一维数组，其中数组的每个元素是一个指向字符串类型对象的指针。
char *lineptr[10]
```

### 多维数组

1. 声明

   ```c
   //在 C 语言中，二维数组是按行排列的。即，先存放`a[0]`行，再存放`a[1]`行。每行中有四个元素也是依次存放。
     char daytab[2][13] = {
       {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
       {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
     };
   
   //如果将二维数组作为参数传递个函数，那么在函数的参数声明中必须指明数组的列数。数组的行数没有太大关系
   	f(int daytab[2][13]){ ... }
     //也可以
     f(int daytab[][13]){ ... }
     //还可以，这种声明形式表明参数是一个指针，它指向具有13个整数元素的一维数组。
     f(int (*daytab)[13]) { ... }
   ```

2. 指针与多维数组

   ```c
   int a[10][20];
   int *b[10];
   
   /*
     1. a 是一个真正的二维数组，它分配了 200 个 int 类型长度的存储空间。
     2. b 该定义仅仅分配了 10 个指针，并且没有对它们初始化。
     3. 指针数组的一个重要优点在于，数组的每一行长度可以不同。b的每个元素不必都指向一个具有 20 个元素的向量。
   */
   ```

### 指向函数的指针

在 C 语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。

```c
#include <stdio.h>
//返回两个数中较大的一个
int max(int a, int b){
  return a>b ? a : b;
}
int main(){
  int x, y, maxval;
  //定义函数指针
  int (*pmax)(int a, int b) = max;
  printf("Input two numbers:");
  scanf("%d %d", &x, &y);
  //使用
  maxval = (*pmax)(x, y);
  printf("Max value: %d\n", maxval);
  return 0;
}
```

### 复杂声明

```c
// * 是一个前缀运算符，其优先级低于(), 所以，声明中必须使用圆括号以保正确的结合顺序。
  //函数返回一个指向 int 类型的指针
    int *f();
  //函数指针
    int (*pf)();
```

## 结构体

结构体是一种数据类型，是一种创建变量的模版，编译器不会为它分配内存空间，就像 int、float、char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，才需要内存来存储。

```c
#include <stdio.h>

int main()
{
  //声明数据类型
  struct member
  {
    char *name;
    int age;
    char group;
    };
  //定义变量
  struct member one;
  /*
    等价
    struct member
    {
      char *name;
      int num;
      int age;
      char group;
    } one;
    */
  //初始化
  one.name = "Tom"
  one.age = 10;
  one.group = 'A';
  //指针
  struct member *pOne;
  pOne = &one;
  printf("%d\n",pOne->age);//只有指针可以 -> 这种方式操作
  //自引用结构
  struct tnode {
    char *word;
    int count;
    struct tnode *left;
    struct tnode *right;
  };
  
  //类型定义
  typedef int Length;
  typedef char* String;
  /*
  联合体
    union u_tag {
      int ival;
      float fval;
      char *sval;
    };
  */
}
```

### 共享内存

1. 在`C` 语言中允许在多个不同变量共享同一内存区的功能称为联合(union)，声明联合。

   ```c
   union U_example
   {
   	float decval;
   	int *pnum;
   	double my_value;
   } u1;
   ```

2. 联合实例所占的字节数是其最大的成员所占的空间。

### 区别

1. 结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。
2. 结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用可内存覆盖技术，同一时刻智能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

```c
struct{
    char name[20];
    int num;
    char sex;
    char profession;
    union{
        float score;
        char course[20];
    } sc;
}
```

## 函数

### 按值传递机制

1. 给函数传送变量时，变量值不会直接传递个函数，而是先制作变量的副本，存储在栈上，再使这个副本可用于函数，而不是使用初始值。
2. 给函数传递变量的地址，它只是传递地址的副本，而不是初始的地址。但是，副本仍是一个地址，仍引用最初的变量。

### 函数原型

```c
double Average(double data_values[],size_t count)
double Sum(double *x,size_t n)

int main(void)
{
    //Average();
    //Sum();
}
```

### 常量参数

```c
//指定函数不修改该变量指向的值。
bool sendMessage(count char* pmessage)
{
    return true;
}
```

### 参数可变函数

```c
/*
 标准库<stdarg.h>
 长度可变的变量列表的基本规则
    在变量数目可变的函数中，至少要有一个固定变量。
    必须调用 va_start() 初始化函数中可变变量列表指针的值。变量指针类型必须声明为 va_list 类型。
    必须有确定何时终止变量列表的方法。例如，在可变的变量列表中，最后一个变量有固定的值，可以检测它，因为它不同于其它变量的值。
*/

#include <stdio.h>
#include <stdarg.h>

double average(double v1, double v2, ...);
int main()
{
    double result = average(1.2,1.2,1.2,1.2,1.2,1.8,0.6,0.0);
    printf("%.2lf\n",result);
    return 0;
}
double average(double v1,double v2, ...){
    va_list parg;
    double sum = v1 + v2;
    double value = 0.0;
    int count = 2;
    //void va_start(va_list parg,last_fixed_arg);
    va_start(parg,v2);
	// va_arg() 函数会返回parg 指定的当前变量值，并将它存储到value中，同时会更新 parg 指针。
    while((value = va_arg(parg,double)) != 0.0){
        sum += value;
        ++count;
    }
    //将 parg 重置为指向NULL，
    va_end(parg);
    return sum/count;
}
```

## 记录

### `#include`

使用尖括号`< >`  和双引号`" "` 的区别在于头文件的搜索路径不同：

* 使用尖括号`< >`，编译器会到系统路径下查找头文件。
* 而使用双引号`" "`，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。

```c
#include <stdHeader.h>
#include "myHeader.h"
```

## 概念

1. **内存泄漏** 当动态分配了一些内存时，没有保留对它们的引用，就会出现内存泄漏，此时无法释放内存。

2. **宏定义** 就是用一个标识符来表示一个字符串，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。

3. `cpu` 的位数（可以理解为一次能处理的数据的位数）。

## 其他

1. `sizeof` 的返回值是无符号整形值。 其类型为 `size_t` ，该类型在头文件 `<stddef.h>` 。

2. 希望返回一个能灵活返回指向各种类型的地址时，就可以使用`void *`。

3. 任何时候对文件的输入/输出都是通过文件描述符标识文件，而不是通过文件名标识文件。

4. 大端小端以及判别。

   ```c
   /*
     1. 大端模式：是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。这种存储模式有点类似于把数据当作字符串顺序处理，地址有小到大增加，而数据从高位往低位存放。
   
     2. 小端模式 (Little-endian)：是指将数据的低位放在内存的地址上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分。
   */
   #include <stdio.h>
   
   int main(){
       union{
           int n;
           char ch;
       } data;
   
       data.n = 0x00000001;
       if (data.ch == 1) {
           printf("Little-endian\n");
       } else {
           printf("Big-endian\n");
       }
   }
   ```

   

