# 概念

## 计算机

1. 位（bit）：一个数字0或一个数字1，代表一位。

2. 字节（Byte）：8个位是一个字节，这是数据存储的最小单位。

3. 原码、反码、补码，以 8 位有符号整数为例。

   ```html
   原码
       0000 0001   十进制 +1
       1000 0001   十进制 -1
   
   反码
       正数的反码等于它的原码
       负数的反码则保留其原码符号位，然后对其他位进行取反操作
       0000 0001   十进制 +1 反码
       1111 1110   十进制 -1 反码
   
   补码
       正数的补码是其本身
       负数的补码是在它的反码基础上加 1
       0000 0001（补码） 十进制 +1
       1111 1111（补码） 十进制 -1
   ```

## Lua

1. **传统的消息系统有两个模块** : **队列**和**发布-订阅**。 在队列中，消费者池从server读取数据，每条记录被池子中的一个消费者消费; 在发布订阅中，记录被广播到所有的消费者。两者均有优缺点。 队列的优点在于它允许你将处理数据的过程分给多个消费者实例，使你可以扩展处理过程。 不好的是，队列不是多订阅者模式的—一旦一个进程读取了数据，数据就会被丢弃。 而发布-订阅系统允许你广播数据到多个进程，但是无法进行扩展处理，因为每条消息都会发送给所有的订阅者。 `kafka 中文官网`
2. **迭代器** ：所谓“迭代器”就是一种可以遍历一种集合中所有元素的机制。`Lua 程序设计（第二版）中文版`
3. **词法域：** 若将一个函数写在另一个函数之内，那么这个位于内部的函数便可以访问外部函数中的局部变量，这项特征称为“词法域”。`Lua 程序设计（第二版）中文版`

## 数据库

1. **事务ACID**

   * **原子性：** 一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
   * **一致性：** 数据库总是从一个一致性的状态转换到另一个一致性的状态。
   * **隔离性：** 一个事务所做的修改在最终提交以前，对其他事务是不可见的。
   * **持久性：**  一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。
2. **隔离级别**

   * **未提交读：** 在该级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据。这也被称为脏读。
   * **提交读：** 大多数数据库系统的默认隔离级别都是`提交读` （mysql 默认可重复读）。在该级别，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。（不可重复读，两次查询的结果可能不同）。
   * **可重复读：** 该级别保证了在同一个时区中多次读取同样记录的结果是一致的。理论上，可重复读隔离级别还是无法解决幻读的问题。所谓**幻读**，指的是当某个事务在读取某个范围内的记录时，另外一个事务在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB 通过多版本并发控制（MVCC）解决了幻读的问题。
   * **可串行化：** 该级别会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。
3. **死锁：** 是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。

## JavaScript

1. 函数是对象，函数名是指针。
2. **环境** ，在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都作为 window 对象的属性和函数都作为 window 对象的属性和方法创建的。
3. 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
4. 当代码在一个环境中执行时，会创建变量对象的一个**作用域链**。作用域链保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。

## Golang

1. 数据竞争会在两个以上的 goroutine 并发访问相同的变量且至少其中一个为写操作时发生。`golang 圣经`
2. 将变量限定在 grouting 内部；如果是多个 goroutine 都需要访问的变量，使用互斥条件来访问。

## Linux

1. 信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。进程不能简单地测试一个变量（如 errno ）来判断是否发生了一个信号，而是必须告诉内核“在此信号发生时，请执行下列操作”。`UNIX 环境高级编程`。
2. 如果一个函数对多个线程来说是可重入的，就说这个函数就是线程安全的。但这并不能说明对信号处理程序来说该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是**异步信号安全** 的。 `UNIX 环境高级编程`。
3. 要使某个函数可重入，调用者必须提供自己的缓冲区，这样每个线程可以使用各自不同的缓冲区避免其他线程的干扰。 `UNIX 环境高级编程`。

