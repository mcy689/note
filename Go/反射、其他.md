## 常量

无类型常量和有类型常量，无类型常量灵活度更高。

```go
package main

import "fmt"

const hello = "hello, world"
const typeHello string = "Hello, World"

func main() {
	type myString string
	var a myString
	a = hello //这样是可以的
	a = typeHello //这样是错误的
  fmt.Println(a)
}
```

## 反射

1. 从底层讲，反射只是一种检查存储在接口变量中的值和类型对的机制。

### 反射的定律

1. 反射从接口值到反射对象。

   ```golang
   /*
     reflect.ValueOf() --> Value
                            |
                            | v.Type()
                            |
     reflect.TypeOf()  --> Type
   */
   ```

2. 反射从反射对象到接口值。

   ```golang
   /*
   
     v.Interface()
   
   */
   ```

3. 要修改反射对象，该值必须可设置。

   ```golang
   var x float64 = 3.4
   p := reflect.ValueOf(&x) //传如引用
   v := p.Elem() //获取引用指向的地址
   v.SetFloat(7.1) //修改 x 值
   fmt.Println(v.CanSet())
   
   
   //结构体
   type T struct {
     A int
     B string
   }
   t := T{23, "skidoo"}
   s := reflect.ValueOf(&t).Elem()
   s.Field(0).SetInt(77)
   s.Field(1).SetString("Sunset Strip")
   ```

## 竞态条件探测器

1. `-race` 命令行标志，可以检查。
2. 只能在运行代码实际触发竞态条件时才检测竞态条件。

```shell
go test -race mypkg //测试程序
go run -race mysrc.go //编译并运行程序
go build -race mycmd //构建命令
go install -race mypkg //安装程序包。
```

### 竞态的例子

```go
func main() {
	start := time.Now()
	var t *time.Timer
	t = time.AfterFunc(randomDuration(), func() {
		fmt.Println(time.Now().Sub(start))
		t.Reset(randomDuration())
	})
	time.Sleep(5 * time.Second)
}

func randomDuration() time.Duration {
	return time.Duration(rand.Int63n(1e9))
}
```



