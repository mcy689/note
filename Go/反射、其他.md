## 反射

1. 从底层讲，反射只是一种检查存储在接口变量中的值和类型对的机制。

### 反射的定律

1. 反射从接口值到反射对象。

   ```golang
   /*
     reflect.ValueOf() --> Value
                            |
                            | v.Type()
                            |
     reflect.TypeOf()  --> Type
   */
   ```

2. 反射从反射对象到接口值。

   ```golang
   /*
   
     v.Interface()
   
   */
   ```

3. 要修改反射对象，该值必须可设置。

   ```golang
   var x float64 = 3.4
   p := reflect.ValueOf(&x) //传如引用
   v := p.Elem() //获取引用指向的地址
   v.SetFloat(7.1) //修改 x 值
   fmt.Println(v.CanSet())
   
   
   //结构体
   type T struct {
     A int
     B string
   }
   t := T{23, "skidoo"}
   s := reflect.ValueOf(&t).Elem()
   s.Field(0).SetInt(77)
   s.Field(1).SetString("Sunset Strip")
   ```

## 错误处理

1. `Go` 代码使用 `error` 值来表示异常状态。

2. `error` 类型是一种接口类型。`error` 变量表示可以将自身描述为字符串的任何值。

```golang
//1. 创建错误
  errors.New("this is error")

//2. 可以使用
	fmt.Errorf("math: square root of negative number %v", -1)

//3. 定义错误。通过类型断言来检查 NegativeSqrtError 然后做处理
  package main

  import "fmt"

  type NegativeSqrtError float64

  func (f NegativeSqrtError) Error() string {
    return fmt.Sprintf("math: square root of negative number %g", float64(f))
  }

  func main() {
    var c error
    c = NegativeSqrtError(2)
    err, ok := c.(NegativeSqrtError)
    fmt.Println(ok, err) //true math: square root of negative number 2
  }
```

## 竞态条件探测器

1. `-race` 命令行标志，可以检查。
2. 只能在运行代码实际触发竞态条件时才检测竞态条件。

```shell
go test -race mypkg //测试程序
go run -race mysrc.go //编译并运行程序
go build -race mycmd //构建命令
go install -race mypkg //安装程序包。
```

