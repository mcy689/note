## 其他

```html
cargo build 可以构建项目
cargo run 可以运行项目
cargo test 可以测试项目
cargo doc 可以为项目构建文档
cargo publish 可以将库发布到
```

## 变量

1. 变量默认是不可改变的。当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。

   ```rust
   fn main() {
       let x = 5;
       println!("The value of x is:{}",x);
       x = 6; //报错
       println!("The value of x is:{}",x);
   }
   ```

2. 在变量之前加 `mut` 来使其可变。

   ```rust
   fn main() {
       let mut x = 5;
       println!("The value of x is:{}",x);
       x = 6;
       println!("The value of x is:{}",x);
   }
   ```

### 常量

1. 常量可以在任何作用域中声明，包括全局作用域。

2. 常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。

   ```rust
   const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
   ```

### 隐藏

1. 定义一个与之前变量同名的新变量。

   ```rust
   fn main(){
       let f = 5;
       let f = f + 1;
       println!("The value of x is:{}",f)
   }
   ```

2. 隐藏与将变量标记为 `mut` 是有区别的。

   * 当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型。
   * 通过 let，可以用这个值进行一些计算，不过计算之后变量仍然是不可变的。

## 类型

### 整数

1. 允许使用 `_` 做为分隔符以方便读数，例如`1_000`，它的值与你指定的 `1000` 相同。

### 浮点

浮点数类型是 `f32` 和 `f64` 。默认是 `f64`。

```rust
fn main(){
  let x :f64 = 2.0;
  let y :f32 = 3.0;
}
```

### bool

```rust
fn main(){
  let t = true;
  let f :bool = false;
}
```

### 字符类型

`char` 类型的大小为四个字节。这意味着可以代表一个 Unicode 标量值。

```rust
fn main(){
  let c = 'z';
}
```

### 复合 - 元组

1. 元组长度固定：一旦声明，其长度不会增加或者缩小。
2. 元组的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。

```rust
fn main(){
  let tup:(i32,f64,u8) = (500,6.4,1);
  
  
  //解构
  let other = (500,6.4,1);
  let (xx, yy, zz) = other;
  
  //使用点号（.）后跟值的索引来直接访问它们。
  let x:(i32,f64,u8) = (500,6.4,1);
  let five_hundred = x.0;
  let six_point_four = x.1;
  let one = x.2;
  println!("{} {} {}",five_hundred,six_point_four,one);
}
```

### 复合 - 数组

1. 访问无效的数组元素，会导致运行时错误，导致 panic。

```rust
let months = [
  "January", "February", 
  "March", "April", 
  "May", "June", 
  "July", "August", 
  "September", "October",
  "November", "December"
];


let a: [i32;5] = [1,2,3,4,5];
```

## 函数

```rust
fn main(){
  demo(10);
}

fn demo(x: i32, y i){
  println!("The value of x is:{}",x);
}
```

### 包含语句和表达式的函数体

1. 语句是执行一些操作但不返回值的指令。

2. 表达式计算并产生一个值。

   ```rust
   fn main() {
      let _x = 5; //这是一个语句
     //下面这个方式是表达式
      let y = {
          let x = 3;
          x + 1   //这里如果加上 ; 就是语句了。
      };
      println!("The value of y is:{}",y);
   }
   ```

### 具有返回值的函数

1. 要在箭头（->）后声明它的类型。
2. 函数的返回值等同于函数体最后一个表达式的值。
3. 使用 `return` 关键字和指定值，可从函数中提前返回。
4. 大部分函数隐式的返回最后的表达式。

```rust
fn main() {
    let x1: i8 = five();
    let x2: i32 = plus_one(10);
    println!("The value of x is:{}", x1);
    println!("The value of x is:{}", x2);
}

fn five() -> i8 {
    5 //这是一个表达式
}

fn plus_one(x: i32) -> i32 {
    let y = x + 1;
    y
}
```

## 控制流

### if

```rust
fn main() {
    let number = 3;
    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}

//在 let 语句中使用if
  //如果if 和 else 分支的值类型是不相容的，代码在编译的时候会报错。
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };
    println!("The value of number is:{}",number);
}
```

### 循环

1. rust 有三种循环：loop、while和for循环。

#### loop 循环

1. `loop` 关键字一直运行直到明确要求停止。

2. `break` 和 `continue` 

   ```rust
   fn main() {
       loop {
           println!("again!");
           break; //退出循环
       }
   }
   ```

3. 循环标签

   ```rust
   fn main() {
       let mut count = 0;
       'counting_up:loop{
           println!("count= {}",count);
           let mut remaining = 10;
           loop {
               println!("remaining = {}",remaining);
               if remaining == 9 {
                   break;
               }
               if count == 2 {
                   break 'counting_up;
               }
               remaining -= 1;
           }
           count += 1;
       }
       println!("End count = {}",count);
   }
   ```

4. 从循环返回。

   场景：重试可能会失败的操作。

   ```rust
   fn main() {
       let mut counter = 0;
       let result = loop{
           counter += 1;
           if counter == 10 {
               break counter * 2;
           }
       };
       println!("The result is {}",result);
   }
   
   ```

#### while 循环

```rust
fn main() {
    let a = [10,20,30,40,50];
    let mut index = 0;
    while index < 5 {
        println!("the value is:{}",a[index]);

        index = index + 1;
    }
}
```

#### for 循环

```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
    for element in a.iter() {
        println!("the value is:{}", element);
    }
}
```

## 所有权

所有权让 Rust 无需垃圾回收即可保障内存安全。通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。

当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。

### 所有权规则

1. rust 中的每一个值都有一个被称为其 **所有者的** 变量。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值就被丢弃。

### 变量与数据交互的方式（一）：移动

由于 String 类型在内存中分成了两块，一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。右侧则是堆上存放内容的内存部分。

```rust
let s1 = String::from("hello");
let s2 = s1; // 在这个操作之后，Rust 认为 `s1` 不再有效。
```

### 变量与数据交互的方式（二）：克隆

如果我们确实需要深度复制 `String` 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的通用函数。

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
}
```

**注意** 

下面的代码是可以编译通过的，原因是像整型这样的在编译时已知大小的类型被整个存储在栈上。所以拷贝其实际的值时快速的。

```rust
fn main() {
    let x = 5;
    let y = x;
    println!("x = {}, y= {}", x ,y);
}
```

### 所有权与函数

将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域
    takes_ownership(s);							// s 的值移动函数里 ...
    let x = 5;											// x 进入作用域
    makes_copy(x);									// 应该移动函数里
  																	// 但 i32 是 Copy 的，所以在后面可继续使用 x
}

fn takes_ownership(some_string: String) {  // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放

fn makes_copy(some_integer: i32) {  // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```

### 返回值与作用域

变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 `drop` 被清理掉，除非数据被移动为另一个变量所有。

```rust
fn main() {
    let s1 = gives_ownership();        // gives_ownership 将返回值移给 s1

    let s2 = String::from("hello");    // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到 takes_and_gives_back 中, 它也将返回值移给 s3
}

fn gives_ownership() -> String {
    let some_string = String::from("hello");

    some_string
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```

### 引用与借用

**引用:** 允许你使用值但不获取其所有权。 

将创建一个引用的行为称为 **借用** 。

引用默认是不允许修改的值。

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("{}", len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

### 可变引用

1. 必须将 `s` 改为 `mut` 。
2. 在调用函数的地方创建一个可变引用 `&mut s`。并在函数签名接受一个可变引用 `some_string: &mut String` 。

```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);

    println!("{}",s);
}

fn change(some_string:&mut String){
    some_string.push_str(", world");
}
```

**注意** 

1. 在同一时间只能有一个对某一个特定数据的可变引用。

   ```rust
   //下面代码说明了这个问题，不能在同一时间多次将 s 作为可变变量借用。
   fn main() {
      let mut s = String::from("hello");
   
      let r1 = &mut s;
      let r2 = &mut s;
   
      println!("{}, {}", r1, r2);
   }
   ```

2. 可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能同时拥有。

   ```rust
   fn main() {
      let mut s = String::from("hello");
      {
          let r1 = &mut s;
          println!("{}",r1);
      }// 在这里离开了作用域，所以完全可以创建一个新的引用。
      let r2 = &mut s;
      println!("{}",r2);
   }
   ```

3. 同时使用可变与不可变引用时也会导致错误。

   ```rust
   fn main() {
      let mut s = String::from("hello");
   
      let r1 = &s;
      let r2 = &s;
      let r3 = &mut s;
   
      println!("{}, {}, and {}", r1, r2, r3);
   }
   ```

### 悬垂引用

通过释放内存时保留指向它的指针而错误地生成一个**悬垂指针** 。所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。

```rust
//报错
fn dangle() -> &String {
    let s = String::from("hello");

    &s //返回字符串 S 的引用，这里 s 离开作用域并被丢弃。其内存被释放。
}
```

### slice 类型

字符串 `slice` 是 `String` 中一部分值的引用。

```rust
fn main() {
    let s = String::from("hello world");
    let hello = &s[0..5];
    println!("{} {}", hello, hello.len());
}
```

## 结构体

